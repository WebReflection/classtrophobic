const Class=((a,b)=>{'use strict';/*! (C) 2017 Andrea Giammarchi - MIT Style License */const
c=b.has,e=b.get,f=b.set,g=b.ownKeys,h=b.deleteProperty,i=b.defineProperty,j=b.construct,l=a.getPrototypeOf,m=a.setPrototypeOf,n=a.defineProperties,o=a.getOwnPropertyDescriptor,
q={isExtensible:x=>b.isExtensible(x.self),preventExtensions:x=>b.preventExtensions(x.self),getPrototypeOf:x=>l(x.self),setPrototypeOf:(x,y)=>m(x.self,y),getOwnPropertyDescriptor:(x,y)=>o(x.self,y),has:(x,y)=>c(x.self,y),get:(x,y,z)=>{
if('super'===y&&!('self'in x))return function(){return x.self=j(x.super,arguments,x.class)};
const A=e(x.self,y);return'function'==typeof A?function(){return A.apply(this===z?x.self:this,arguments)}:A},set:(x,y,z)=>f(x.self,y,z),deleteProperty:(x,y)=>h(x.self,y),defineProperty:(x,y,z)=>i(x.self,y,z),ownKeys:x=>g(x.self),apply:(x,y,z)=>b.apply(x.self,y,z),construct:(x,y,z)=>j(x.self,y,z)},
s={get:(x,y)=>function(){const z=l(x),A=z[y];let B,C=z;do C=l(C);while(A===C[y]);try{B=C[y].apply(m(x,C),arguments)}finally{m(x,z)}return B}},u={
get:(x,y)=>function(){const z=l(x),A=x[y];let B,C=z;for(;A===C[y];)C=l(C);x.method=C[y];try{B=x.method.apply(m(x,l(C)),arguments)}finally{m(x,z).method=A}return B}},
w=new Set(['constructor','extends','static']);return function(y){const z=y.constructor,A=y.static,B=y.extends,C=y.hasOwnProperty('constructor')?B?class extends B{constructor(){const F={super:B,class:C};return z.apply(new Proxy(F,q),arguments)||F.self}}:class{constructor(){return z.apply(this,arguments)||this}}:B?class extends B{}:class{},D={super:{get(){return new Proxy(C,u)}}},E={super:{get(){return new Proxy(this,s)}}};return g(y).filter(F=>!w.has(F)).forEach(F=>{E[F]=o(y,F),E[F].enumerable=!1}),n(C.prototype,E),A&&g(A).forEach(F=>{D[F]=o(A,F),D[F].enumerable=!1}),n(C,D)}})(Object,Reflect);try{module.exports=Class}catch(a){}
